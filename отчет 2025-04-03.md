## Отчет по Диалогу: Реализация и Улучшение Системы Видео-Водяных Знаков

**Цель:** Разработка и адаптация системы встраивания и извлечения слепых цифровых водяных знаков (ВЗ) в видео, основанной на научной статье Fu et al., с последующим улучшением её практической применимости, робастности, стабильности и производительности.

**1. Исходная Точка и Базовый Алгоритм**

*   **Основа:** Научная статья "Robust and blind video watermarking against online sharing platforms" (Fu et al.).
*   **Ключевые Технологии:**
    *   Двойное Древовидное Комплексное Вейвлет-Преобразование (DTCWT) для предобработки и выделения низкочастотной подполосы (LL).
    *   Разделение LL-подполосы на концентрические кольца (для устойчивости к вращению).
    *   Дискретное Косинусное Преобразование (DCT) данных выбранного кольца.
    *   Сингулярное Разложение (SVD) DCT-коэффициентов.
    *   Встраивание бита ВЗ путем модификации отношения максимальных сингулярных значений (`s1`, `s2`) пары соседних кадров (`s1_mod / s2_mod`) относительно порога (`alpha` и `1/alpha`).
*   **Начальная Реализация:** Код (`embedder.py`, `extractor.py`) уже содержал доработки: адаптивная альфа (на основе энтропии), несколько методов выбора кольца ('adaptive', 'deterministic', 'keypoint', 'multi_ring', 'fixed'), опциональная перцептуальная маскировка, базовая параллелизация эмбеддера.

**2. Преодоление Практических Проблем (Этап 1)**

*   **Проблема:** Использование lossless-кодека (HFYU) приводило к огромным файлам и несовместимости с плеерами.
*   **Решение:** Переход на распространенный lossy-кодек **XVID** с контейнером **AVI**. Это решило проблемы размера и совместимости.

**3. Борьба за Робустность к Сжатию (Этап 2)**

*   **Проблема:** Переход на XVID выявил высокую частоту ошибок (BER ~19.5%), так как сжатие искажало отношение сингулярных значений.
*   **Решение (Итеративное):**
    *   **Увеличение Силы Встраивания:** Параметры `ALPHA_MIN` и `ALPHA_MAX` были увеличены (до 1.005 и 1.1 соответственно), чтобы создать больший "зазор" между состояниями для бита 0 и 1.
    *   **Смена Компонента Встраивания:** Встраивание перенесено из яркостного компонента Y в цветоразностный компонент **Cr** (`EMBED_COMPONENT = 1`), который менее подвержен искажениям при сжатии и менее заметен для глаза.
*   **Результат:** Комбинация этих методов **резко снизила BER до ~0.78%**, подтвердив эффективность обоих подходов для противостояния искажениям кодека XVID.

**4. Обеспечение Стабильности и Синхронизации (Этап 3)**

*   **Проблема:** Адаптивные методы выбора кольца могли привести к рассинхронизации между эмбеддером (работающим с оригиналом) и экстрактором (работающим с искаженным видео).
*   **Решение:**
    *   Выбран **детерминистический метод** выбора кольца (`RING_SELECTION_METHOD = 'deterministic'`), использующий устойчивый к небольшим искажениям перцептивный хеш (pHash) кадра.
    *   Реализовано сохранение эмбеддером индексов выбранных колец в файл `selected_rings.json`.
    *   Экстрактору добавлена опция (`USE_SAVED_RINGS = True`) для принудительного использования индексов из файла, гарантируя синхронизацию.

**5. Оптимизация Производительности (Этап 4)**

*   **Проблема:** Длительное время выполнения (минуты для коротких роликов).
*   **Решение (Итеративное):**
    *   **Профилирование:** Использованы `cProfile` и `pstats` для выявления узких мест.
    *   **Обнаружение Ботлнека:** Функция `ring_division` (из-за неэффективной конвертации NumPy -> list) и `dtcwt_transform` были основными проблемами.
    *   **Оптимизация `ring_division`:** Переход на использование **NumPy индексации** напрямую, без конвертации в списки кортежей.
    *   **Параллелизация Экстрактора:** Добавлен `ThreadPoolExecutor` в экстрактор (аналогично эмбеддеру) после оптимизации `ring_division`.
*   **Результат:** **Значительное ускорение:** эмбеддер примерно в 3.5 раза, экстрактор почти в 13 раз. Время выполнения сократилось до десятков секунд.

**6. Повышение Надежности и Функциональности (Этап 5)**

*   **Цели:** Внедрение осмысленной полезной нагрузки, повышение устойчивости к ошибкам и частичной потере данных.
*   **Реализация:**
    *   **Payload:** Переход от случайных бит к стандартному **UUID** (128 бит).
    *   **ECC:** Интегрированы коды **BCH** (`bchlib`) для обнаружения и исправления ошибок. Выбраны параметры `m=8, t=5`. Эмбеддер добавляет ECC к payload.
    *   **Избыточность:** Реализовано повторение ECC-пакета на основе процента покрытия (`COVERAGE_PERCENTAGE`). Экстрактор агрегирует биты из разных повторений голосованием по позициям.
    *   **Обнаруженная Проблема с ECC:** При тестировании с 50% покрытием выяснилось, что извлекаемого количества бит (226) **недостаточно** для формирования полного BCH-блока (ожидалось 255 бит на основе m=8, но фактически эмбеддер создавал 168 бит). Из-за этого проверка в экстракторе не проходила, и **ECC-декодирование пропускалось**. Успешное извлечение было связано с низкой ошибкой базового метода.
    *   **Корректировка Понимания ECC:** Уточнено, что для BCH(m=8, t=5) и 128-битных данных `bchlib` создает пакет 168 бит (128 данных + 40 ECC). Экстрактор был скорректирован для ожидания 168 бит, но проблема недостатка данных при 50% покрытии осталась. Позже, при переходе на 64-битный ID, было решено **дополнять данные до `bch.k` (215 бит)**, чтобы получить стандартный блок `bch.n = 255` бит.

**7. Увеличение Плотности Встраивания и Финальная Реализация (Этап 6)**

*   **Цели:** Увеличить количество встраиваемой информации на пару кадров, использовать более практичный ID, реализовать надежное голосование по пакетам.
*   **Реализация:**
    *   **Multi-Ring (N=2):** Внедрено встраивание **2 бит на пару кадров** (`BITS_PER_PAIR = 2`) с использованием **2 лучших колец** (`RING_SELECTION_METHOD = 'multi_ring'`, `NUM_RINGS_TO_USE = 2`). Модифицированы `embed_frame_pair`, `_embed_frame_pair_worker`, `select_embedding_rings`.
    *   **64-битный ID:** Полезная нагрузка заменена на **8 байт случайных данных** (`os.urandom(8)`), `PAYLOAD_LEN_BYTES = 8`.
    *   **ECC (Уточнение):** Используется BCH(m=8, t=5). 64 бита ID дополняются нулями до `k=215` бит, добавляются 40 бит ECC, итого **пакет 255 бит**.
    *   **Ограничение Повторов:** Вместо процента покрытия введено ограничение `MAX_PACKET_REPEATS = 5`. Эмбеддер встраивает до 5 полных пакетов (или пока не кончится видео).
    *   **Экстрактор с Голосованием по Пакетам:** Экстрактор извлекает все доступные биты, делит их на полные пакеты по 255 бит, пытается **декодировать каждый пакет независимо** с помощью ECC, собирает успешно декодированные 8-байтные ID и **выбирает финальный ID большинством голосов** (`collections.Counter`).
*   **Минимальная Длина:** Рассчитана минимальная длина видео для встраивания 1 пакета (~8.5 сек @ 30 FPS) и 5 пакетов (~42.5 сек @ 30 FPS) с новыми параметрами.

**8. Текущий Статус**

*   Предоставлен полный код **`embedder.py`**, реализующий: 64-битный ID, Multi-Ring (N=2), ECC BCH(m=8, t=5) с паддингом до k=215 (пакет 255 бит), ограничение до 5 повторов пакета, сохранение списков колец.
*   Предоставлен полный код **`extractor.py`**, реализующий: извлечение 2 бит/пару из сохраненных списков колец, деление на пакеты по 255 бит, независимое ECC-декодирование каждого пакета, голосование по большинству среди успешно декодированных 64-битных ID.
*   Система теоретически готова к тестированию повышенной плотности встраивания и робастности за счет пакетного голосования.

**Основные Преодоленные Трудности:**

*   Непрактичность lossless-кодеков -> Переход на XVID.
*   Высокий BER при сжатии -> Увеличение Alpha + смена компонента на Cr.
*   Риск рассинхронизации колец -> Детерминистический выбор + сохранение/загрузка индексов.
*   Низкая производительность -> Профилирование + оптимизация `ring_division` + параллелизация.
*   Неработающий ECC из-за недостаточного покрытия -> Корректный расчет размера пакета + увеличение покрытия / ограничение повторов + переход на пакетное голосование.
*   Необходимость большей плотности -> Реализация Multi-Ring.
*   Избыточность UUID -> Переход на 64-битный ID.

Этот диалог демонстрирует итеративный процесс разработки, где решение одной проблемы часто выявляет следующую, требуя анализа, адаптации алгоритмов и тщательного тестирования. Мы прошли путь от базовой концепции до значительно более робастной, производительной и функциональной системы.